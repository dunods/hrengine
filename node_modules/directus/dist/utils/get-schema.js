"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSchema = void 0;
const schema_1 = __importDefault(require("@directus/schema"));
const lodash_1 = require("lodash");
const app_access_permissions_1 = require("../database/system-data/app-access-permissions");
const collections_1 = require("../database/system-data/collections");
const fields_1 = require("../database/system-data/fields");
const relations_1 = require("../database/system-data/relations");
const logger_1 = __importDefault(require("../logger"));
const to_array_1 = require("../utils/to-array");
const get_default_value_1 = __importDefault(require("./get-default-value"));
const get_local_type_1 = __importDefault(require("./get-local-type"));
const merge_permissions_1 = require("./merge-permissions");
async function getSchema(options) {
    var _a, _b, _c;
    // Allows for use in the CLI
    const database = (options === null || options === void 0 ? void 0 : options.database) || require('../database').default;
    const schemaInspector = schema_1.default(database);
    const result = {
        collections: {},
        relations: [],
        permissions: [],
    };
    let permissions = [];
    if ((options === null || options === void 0 ? void 0 : options.accountability) && options.accountability.admin !== true) {
        const permissionsForRole = await database
            .select('*')
            .from('directus_permissions')
            .where({ role: options.accountability.role });
        permissions = permissionsForRole.map((permissionRaw) => {
            if (permissionRaw.permissions && typeof permissionRaw.permissions === 'string') {
                permissionRaw.permissions = JSON.parse(permissionRaw.permissions);
            }
            if (permissionRaw.validation && typeof permissionRaw.validation === 'string') {
                permissionRaw.validation = JSON.parse(permissionRaw.validation);
            }
            if (permissionRaw.presets && typeof permissionRaw.presets === 'string') {
                permissionRaw.presets = JSON.parse(permissionRaw.presets);
            }
            if (permissionRaw.fields && typeof permissionRaw.fields === 'string') {
                permissionRaw.fields = permissionRaw.fields.split(',');
            }
            return permissionRaw;
        });
        if (options.accountability.app === true) {
            permissions = merge_permissions_1.mergePermissions(permissions, app_access_permissions_1.appAccessMinimalPermissions.map((perm) => ({ ...perm, role: options.accountability.role })));
        }
    }
    result.permissions = permissions;
    const schemaOverview = await schemaInspector.overview();
    const collections = [
        ...(await database
            .select('collection', 'singleton', 'note', 'sort_field', 'accountability')
            .from('directus_collections')),
        ...collections_1.systemCollectionRows,
    ];
    for (const [collection, info] of Object.entries(schemaOverview)) {
        if (!info.primary) {
            logger_1.default.warn(`Collection "${collection}" doesn't have a primary key column and will be ignored`);
            continue;
        }
        const collectionMeta = collections.find((collectionMeta) => collectionMeta.collection === collection);
        result.collections[collection] = {
            collection,
            primary: info.primary,
            singleton: (collectionMeta === null || collectionMeta === void 0 ? void 0 : collectionMeta.singleton) === true || (collectionMeta === null || collectionMeta === void 0 ? void 0 : collectionMeta.singleton) === 'true' || (collectionMeta === null || collectionMeta === void 0 ? void 0 : collectionMeta.singleton) === 1,
            note: (collectionMeta === null || collectionMeta === void 0 ? void 0 : collectionMeta.note) || null,
            sortField: (collectionMeta === null || collectionMeta === void 0 ? void 0 : collectionMeta.sort_field) || null,
            accountability: collectionMeta ? collectionMeta.accountability : 'all',
            fields: lodash_1.mapValues(schemaOverview[collection].columns, (column) => {
                var _a, _b;
                return ({
                    field: column.column_name,
                    defaultValue: (_a = get_default_value_1.default(column)) !== null && _a !== void 0 ? _a : null,
                    nullable: (_b = column.is_nullable) !== null && _b !== void 0 ? _b : true,
                    type: get_local_type_1.default(column) || 'alias',
                    precision: column.numeric_precision || null,
                    scale: column.numeric_scale || null,
                    special: [],
                    note: null,
                    alias: false,
                });
            }),
        };
    }
    const fields = [
        ...(await database
            .select('id', 'collection', 'field', 'special', 'note')
            .from('directus_fields')),
        ...fields_1.systemFieldRows,
    ].filter((field) => (field.special ? to_array_1.toArray(field.special) : []).includes('no-data') === false);
    for (const field of fields) {
        if (!result.collections[field.collection])
            continue;
        const existing = result.collections[field.collection].fields[field.field];
        result.collections[field.collection].fields[field.field] = {
            field: field.field,
            defaultValue: (_a = existing === null || existing === void 0 ? void 0 : existing.defaultValue) !== null && _a !== void 0 ? _a : null,
            nullable: (_b = existing === null || existing === void 0 ? void 0 : existing.nullable) !== null && _b !== void 0 ? _b : true,
            type: existing
                ? get_local_type_1.default(schemaOverview[field.collection].columns[field.field], {
                    special: field.special ? to_array_1.toArray(field.special) : [],
                })
                : 'alias',
            precision: (existing === null || existing === void 0 ? void 0 : existing.precision) || null,
            scale: (existing === null || existing === void 0 ? void 0 : existing.scale) || null,
            special: field.special ? to_array_1.toArray(field.special) : [],
            note: field.note,
            alias: (_c = existing === null || existing === void 0 ? void 0 : existing.alias) !== null && _c !== void 0 ? _c : true,
        };
    }
    const relations = [...(await database.select('*').from('directus_relations')), ...relations_1.systemRelationRows];
    result.relations = relations.map((relation) => ({
        ...relation,
        one_allowed_collections: relation.one_allowed_collections ? to_array_1.toArray(relation.one_allowed_collections) : null,
    }));
    return result;
}
exports.getSchema = getSchema;
