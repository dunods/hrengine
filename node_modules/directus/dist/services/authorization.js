"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AuthorizationService = void 0;
const lodash_1 = require("lodash");
const database_1 = __importDefault(require("../database"));
const exceptions_1 = require("../exceptions");
const generate_joi_1 = __importDefault(require("../utils/generate-joi"));
const parse_filter_1 = require("../utils/parse-filter");
const items_1 = require("./items");
const payload_1 = require("./payload");
class AuthorizationService {
    constructor(options) {
        this.knex = options.knex || database_1.default;
        this.accountability = options.accountability || null;
        this.schema = options.schema;
        this.payloadService = new payload_1.PayloadService('directus_permissions', {
            knex: this.knex,
            schema: this.schema,
        });
    }
    async processAST(ast, action = 'read') {
        const collectionsRequested = getCollectionsFromAST(ast);
        const permissionsForCollections = lodash_1.uniqWith(this.schema.permissions.filter((permission) => {
            return (permission.action === action &&
                collectionsRequested.map(({ collection }) => collection).includes(permission.collection));
        }), (curr, prev) => curr.collection === prev.collection && curr.action === prev.action && curr.role === prev.role);
        // If the permissions don't match the collections, you don't have permission to read all of them
        const uniqueCollectionsRequestedCount = lodash_1.uniq(collectionsRequested.map(({ collection }) => collection)).length;
        if (uniqueCollectionsRequestedCount !== permissionsForCollections.length) {
            throw new exceptions_1.ForbiddenException();
        }
        validateFields(ast);
        applyFilters(ast, this.accountability);
        return ast;
        /**
         * Traverses the AST and returns an array of all collections that are being fetched
         */
        function getCollectionsFromAST(ast) {
            const collections = [];
            if (ast.type === 'm2a') {
                collections.push(...ast.names.map((name) => ({ collection: name, field: ast.fieldKey })));
                /** @TODO add nestedNode */
            }
            else {
                collections.push({
                    collection: ast.name,
                    field: ast.type === 'root' ? null : ast.fieldKey,
                });
                for (const nestedNode of ast.children) {
                    if (nestedNode.type !== 'field') {
                        collections.push(...getCollectionsFromAST(nestedNode));
                    }
                }
            }
            return collections;
        }
        function validateFields(ast) {
            if (ast.type !== 'field' && ast.type !== 'm2a') {
                /** @TODO remove m2a check */
                const collection = ast.name;
                // We check the availability of the permissions in the step before this is run
                const permissions = permissionsForCollections.find((permission) => permission.collection === collection);
                const allowedFields = permissions.fields || [];
                for (const childNode of ast.children) {
                    if (childNode.type !== 'field') {
                        validateFields(childNode);
                        continue;
                    }
                    if (allowedFields.includes('*'))
                        continue;
                    const fieldKey = childNode.name;
                    if (allowedFields.includes(fieldKey) === false) {
                        throw new exceptions_1.ForbiddenException();
                    }
                }
            }
        }
        function applyFilters(ast, accountability) {
            if (ast.type !== 'field' && ast.type !== 'm2a') {
                /** @TODO remove m2a check */
                const collection = ast.name;
                // We check the availability of the permissions in the step before this is run
                const permissions = permissionsForCollections.find((permission) => permission.collection === collection);
                const parsedPermissions = parse_filter_1.parseFilter(permissions.permissions, accountability);
                if (!ast.query.filter || Object.keys(ast.query.filter).length === 0) {
                    ast.query.filter = { _and: [] };
                }
                else {
                    ast.query.filter = { _and: [ast.query.filter] };
                }
                if (parsedPermissions && Object.keys(parsedPermissions).length > 0) {
                    ast.query.filter._and.push(parsedPermissions);
                }
                if (ast.query.filter._and.length === 0)
                    delete ast.query.filter._and;
                if (permissions.limit && ast.query.limit && ast.query.limit > permissions.limit) {
                    throw new exceptions_1.ForbiddenException();
                }
                // Default to the permissions limit if limit hasn't been set
                if (permissions.limit && !ast.query.limit) {
                    ast.query.limit = permissions.limit;
                }
                ast.children = ast.children.map((child) => applyFilters(child, accountability));
            }
            return ast;
        }
    }
    /**
     * Checks if the provided payload matches the configured permissions, and adds the presets to the payload.
     */
    validatePayload(action, collection, data) {
        var _a, _b, _c;
        const validationErrors = [];
        const payload = lodash_1.cloneDeep(data);
        let permission;
        if (((_a = this.accountability) === null || _a === void 0 ? void 0 : _a.admin) === true) {
            permission = {
                id: 0,
                role: (_b = this.accountability) === null || _b === void 0 ? void 0 : _b.role,
                collection,
                action,
                permissions: {},
                validation: {},
                limit: null,
                fields: ['*'],
                presets: {},
            };
        }
        else {
            permission = this.schema.permissions.find((permission) => {
                return permission.collection === collection && permission.action === action;
            });
            if (!permission)
                throw new exceptions_1.ForbiddenException();
            // Check if you have permission to access the fields you're trying to access
            const allowedFields = permission.fields || [];
            if (allowedFields.includes('*') === false) {
                const keysInData = Object.keys(payload);
                const invalidKeys = keysInData.filter((fieldKey) => allowedFields.includes(fieldKey) === false);
                if (invalidKeys.length > 0) {
                    throw new exceptions_1.ForbiddenException();
                }
            }
        }
        const preset = parse_filter_1.parseFilter(permission.presets || {}, this.accountability);
        const payloadWithPresets = lodash_1.merge({}, preset, payload);
        const requiredColumns = [];
        for (const [name, field] of Object.entries(this.schema.collections[collection].fields)) {
            const specials = (_c = field === null || field === void 0 ? void 0 : field.special) !== null && _c !== void 0 ? _c : [];
            const hasGenerateSpecial = ['uuid', 'date-created', 'role-created', 'user-created'].some((name) => specials.includes(name));
            const isRequired = field.nullable === false && field.defaultValue === null && hasGenerateSpecial === false;
            if (isRequired) {
                requiredColumns.push(name);
            }
        }
        if (requiredColumns.length > 0) {
            permission.validation = {
                _and: [permission.validation, {}],
            };
            if (action === 'create') {
                for (const name of requiredColumns) {
                    permission.validation._and[1][name] = {
                        _submitted: true,
                    };
                }
            }
            else {
                for (const name of requiredColumns) {
                    permission.validation._and[1][name] = {
                        _nnull: true,
                    };
                }
            }
        }
        validationErrors.push(...this.validateJoi(parse_filter_1.parseFilter(permission.validation || {}, this.accountability), payloadWithPresets));
        if (validationErrors.length > 0)
            throw validationErrors;
        return payloadWithPresets;
    }
    validateJoi(validation, payload) {
        if (!validation)
            return [];
        const errors = [];
        /**
         * Note there can only be a single _and / _or per level
         */
        if (Object.keys(validation)[0] === '_and') {
            const subValidation = Object.values(validation)[0];
            const nestedErrors = lodash_1.flatten(subValidation.map((subObj) => {
                return this.validateJoi(subObj, payload);
            })).filter((err) => err);
            errors.push(...nestedErrors);
        }
        else if (Object.keys(validation)[0] === '_or') {
            const subValidation = Object.values(validation)[0];
            const nestedErrors = lodash_1.flatten(subValidation.map((subObj) => this.validateJoi(subObj, payload)));
            const allErrored = nestedErrors.every((err) => err);
            if (allErrored) {
                errors.push(...nestedErrors);
            }
        }
        else {
            const schema = generate_joi_1.default(validation);
            const { error } = schema.validate(payload, { abortEarly: false });
            if (error) {
                errors.push(...error.details.map((details) => new exceptions_1.FailedValidationException(details)));
            }
        }
        return errors;
    }
    async checkAccess(action, collection, pk) {
        var _a;
        if (((_a = this.accountability) === null || _a === void 0 ? void 0 : _a.admin) === true)
            return;
        const itemsService = new items_1.ItemsService(collection, {
            accountability: this.accountability,
            knex: this.knex,
            schema: this.schema,
        });
        const query = {
            fields: ['*'],
        };
        if (Array.isArray(pk)) {
            const result = await itemsService.readMany(pk, query, { permissionsAction: action });
            if (!result)
                throw new exceptions_1.ForbiddenException();
            if (result.length !== pk.length)
                throw new exceptions_1.ForbiddenException();
        }
        else {
            const result = await itemsService.readOne(pk, query, { permissionsAction: action });
            if (!result)
                throw new exceptions_1.ForbiddenException();
        }
    }
}
exports.AuthorizationService = AuthorizationService;
