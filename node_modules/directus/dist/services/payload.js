"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PayloadService = void 0;
const argon2_1 = __importDefault(require("argon2"));
const date_fns_1 = require("date-fns");
const joi_1 = __importDefault(require("joi"));
const lodash_1 = require("lodash");
const uuid_1 = require("uuid");
const database_1 = __importDefault(require("../database"));
const exceptions_1 = require("../exceptions");
const to_array_1 = require("../utils/to-array");
const items_1 = require("./items");
/**
 * Process a given payload for a collection to ensure the special fields (hash, uuid, date etc) are
 * handled correctly.
 */
class PayloadService {
    constructor(collection, options) {
        /**
         * @todo allow this to be extended
         *
         * @todo allow these extended special types to have "field dependencies"?
         * f.e. the file-links transformer needs the id and filename_download to be fetched from the DB
         * in order to work
         */
        this.transformers = {
            async hash({ action, value }) {
                if (!value)
                    return;
                if (action === 'create' || action === 'update') {
                    return await argon2_1.default.hash(String(value));
                }
                return value;
            },
            async uuid({ action, value }) {
                if (action === 'create' && !value) {
                    return uuid_1.v4();
                }
                return value;
            },
            async boolean({ action, value }) {
                if (action === 'read') {
                    return value === true || value === 1 || value === '1';
                }
                return value;
            },
            async json({ action, value }) {
                if (action === 'read') {
                    if (typeof value === 'string') {
                        try {
                            return JSON.parse(value);
                        }
                        catch {
                            return value;
                        }
                    }
                }
                return value;
            },
            async conceal({ action, value }) {
                if (action === 'read')
                    return value ? '**********' : null;
                return value;
            },
            async 'user-created'({ action, value, accountability }) {
                if (action === 'create')
                    return (accountability === null || accountability === void 0 ? void 0 : accountability.user) || null;
                return value;
            },
            async 'user-updated'({ action, value, accountability }) {
                if (action === 'update')
                    return (accountability === null || accountability === void 0 ? void 0 : accountability.user) || null;
                return value;
            },
            async 'role-created'({ action, value, accountability }) {
                if (action === 'create')
                    return (accountability === null || accountability === void 0 ? void 0 : accountability.role) || null;
                return value;
            },
            async 'role-updated'({ action, value, accountability }) {
                if (action === 'update')
                    return (accountability === null || accountability === void 0 ? void 0 : accountability.role) || null;
                return value;
            },
            async 'date-created'({ action, value }) {
                if (action === 'create')
                    return new Date();
                return value;
            },
            async 'date-updated'({ action, value }) {
                if (action === 'update')
                    return new Date();
                return value;
            },
            async csv({ action, value }) {
                if (!value)
                    return;
                if (action === 'read')
                    return value.split(',');
                if (Array.isArray(value))
                    return value.join(',');
                return value;
            },
        };
        this.accountability = options.accountability || null;
        this.knex = options.knex || database_1.default;
        this.collection = collection;
        this.schema = options.schema;
        return this;
    }
    async processValues(action, payload) {
        const processedPayload = to_array_1.toArray(payload);
        if (processedPayload.length === 0)
            return [];
        const fieldsInPayload = Object.keys(processedPayload[0]);
        let specialFieldsInCollection = Object.entries(this.schema.collections[this.collection].fields).filter(([_name, field]) => field.special && field.special.length > 0);
        if (action === 'read') {
            specialFieldsInCollection = specialFieldsInCollection.filter(([name]) => {
                return fieldsInPayload.includes(name);
            });
        }
        await Promise.all(processedPayload.map(async (record) => {
            await Promise.all(specialFieldsInCollection.map(async ([name, field]) => {
                const newValue = await this.processField(field, record, action, this.accountability);
                if (newValue !== undefined)
                    record[name] = newValue;
            }));
        }));
        await this.processDates(processedPayload, action);
        if (['create', 'update'].includes(action)) {
            processedPayload.forEach((record) => {
                for (const [key, value] of Object.entries(record)) {
                    if (Array.isArray(value) || (typeof value === 'object' && value instanceof Date !== true && value !== null)) {
                        record[key] = JSON.stringify(value);
                    }
                }
            });
        }
        if (Array.isArray(payload)) {
            return processedPayload;
        }
        return processedPayload[0];
    }
    async processField(field, payload, action, accountability) {
        if (!field.special)
            return payload[field.field];
        const fieldSpecials = field.special ? to_array_1.toArray(field.special) : [];
        let value = lodash_1.clone(payload[field.field]);
        for (const special of fieldSpecials) {
            if (special in this.transformers) {
                value = await this.transformers[special]({
                    action,
                    value,
                    payload,
                    accountability,
                });
            }
        }
        return value;
    }
    /**
     * Knex returns `datetime` and `date` columns as Date.. This is wrong for date / datetime, as those
     * shouldn't return with time / timezone info respectively
     */
    async processDates(payloads, action) {
        const fieldsInCollection = Object.entries(this.schema.collections[this.collection].fields);
        const dateColumns = fieldsInCollection.filter(([_name, field]) => ['dateTime', 'date', 'timestamp'].includes(field.type));
        if (dateColumns.length === 0)
            return payloads;
        for (const [name, dateColumn] of dateColumns) {
            for (const payload of payloads) {
                let value = payload[name];
                if (value === null || value === '0000-00-00') {
                    payload[name] = null;
                    continue;
                }
                if (!value)
                    continue;
                if (action === 'read') {
                    if (typeof value === 'string')
                        value = new Date(value);
                    if (dateColumn.type === 'timestamp') {
                        const newValue = date_fns_1.formatISO(value);
                        payload[name] = newValue;
                    }
                    if (dateColumn.type === 'dateTime') {
                        // Strip off the Z at the end of a non-timezone datetime value
                        const newValue = date_fns_1.format(value, "yyyy-MM-dd'T'HH:mm:ss");
                        payload[name] = newValue;
                    }
                    if (dateColumn.type === 'date') {
                        // Strip off the time / timezone information from a date-only value
                        const newValue = date_fns_1.format(value, 'yyyy-MM-dd');
                        payload[name] = newValue;
                    }
                }
                else {
                    if (value instanceof Date === false) {
                        if (dateColumn.type === 'date') {
                            const newValue = date_fns_1.parse(value, 'yyyy-MM-dd', new Date());
                            payload[name] = newValue;
                        }
                        if (dateColumn.type === 'timestamp' || dateColumn.type === 'dateTime') {
                            const newValue = date_fns_1.parseISO(value);
                            payload[name] = newValue;
                        }
                    }
                }
            }
        }
        return payloads;
    }
    /**
     * Recursively save/update all nested related Any-to-One items
     */
    async processA2O(data) {
        const relations = this.schema.relations.filter((relation) => {
            return relation.many_collection === this.collection;
        });
        const revisions = [];
        const payload = lodash_1.cloneDeep(data);
        // Only process related records that are actually in the payload
        const relationsToProcess = relations.filter((relation) => {
            return relation.many_field in payload && lodash_1.isPlainObject(payload[relation.many_field]);
        });
        for (const relation of relationsToProcess) {
            // If the required a2o configuration fields are missing, this is a m2o instead of an a2o
            if (!relation.one_collection_field || !relation.one_allowed_collections)
                continue;
            const relatedCollection = payload[relation.one_collection_field];
            if (!relatedCollection) {
                throw new exceptions_1.InvalidPayloadException(`Can't update nested record "${relation.many_collection}.${relation.many_field}" without field "${relation.many_collection}.${relation.one_collection_field}" being set`);
            }
            const allowedCollections = relation.one_allowed_collections;
            if (allowedCollections.includes(relatedCollection) === false) {
                throw new exceptions_1.InvalidPayloadException(`"${relation.many_collection}.${relation.many_field}" can't be linked to collection "${relatedCollection}`);
            }
            const itemsService = new items_1.ItemsService(relatedCollection, {
                accountability: this.accountability,
                knex: this.knex,
                schema: this.schema,
            });
            const relatedPrimary = this.schema.collections[relatedCollection].primary;
            const relatedRecord = payload[relation.many_field];
            const hasPrimaryKey = relatedPrimary in relatedRecord;
            let relatedPrimaryKey = relatedRecord[relatedPrimary];
            const exists = hasPrimaryKey &&
                !!(await this.knex
                    .select(relatedPrimary)
                    .from(relatedCollection)
                    .where({ [relatedPrimary]: relatedPrimaryKey })
                    .first());
            if (exists) {
                await itemsService.updateOne(relatedPrimaryKey, relatedRecord);
            }
            else {
                relatedPrimaryKey = await itemsService.createOne(relatedRecord, {
                    onRevisionCreate: (id) => revisions.push(id),
                });
            }
            // Overwrite the nested object with just the primary key, so the parent level can be saved correctly
            payload[relation.many_field] = relatedPrimaryKey;
        }
        return { payload, revisions };
    }
    /**
     * Save/update all nested related m2o items inside the payload
     */
    async processM2O(data) {
        const payload = lodash_1.cloneDeep(data);
        // All the revisions saved on this level
        const revisions = [];
        // Many to one relations that exist on the current collection
        const relations = this.schema.relations.filter((relation) => {
            return relation.many_collection === this.collection;
        });
        // Only process related records that are actually in the payload
        const relationsToProcess = relations.filter((relation) => {
            return relation.many_field in payload && lodash_1.isObject(payload[relation.many_field]);
        });
        for (const relation of relationsToProcess) {
            // If no "one collection" exists, this is a A2O, not a M2O
            if (!relation.one_collection || !relation.one_primary)
                continue;
            // Items service to the related collection
            const itemsService = new items_1.ItemsService(relation.one_collection, {
                accountability: this.accountability,
                knex: this.knex,
                schema: this.schema,
            });
            const relatedRecord = payload[relation.many_field];
            const hasPrimaryKey = relation.one_primary in relatedRecord;
            if (['string', 'number'].includes(typeof relatedRecord))
                continue;
            let relatedPrimaryKey = relatedRecord[relation.one_primary];
            const exists = hasPrimaryKey &&
                !!(await this.knex
                    .select(relation.one_primary)
                    .from(relation.one_collection)
                    .where({ [relation.one_primary]: relatedPrimaryKey })
                    .first());
            if (exists) {
                await itemsService.updateOne(relatedPrimaryKey, relatedRecord);
            }
            else {
                relatedPrimaryKey = await itemsService.createOne(relatedRecord, {
                    onRevisionCreate: (id) => revisions.push(id),
                });
            }
            // Overwrite the nested object with just the primary key, so the parent level can be saved correctly
            payload[relation.many_field] = relatedPrimaryKey;
        }
        return { payload, revisions };
    }
    /**
     * Recursively save/update all nested related o2m items
     */
    async processO2M(data, parent) {
        const revisions = [];
        const relations = this.schema.relations.filter((relation) => {
            return relation.one_collection === this.collection;
        });
        const payload = lodash_1.cloneDeep(data);
        // Only process related records that are actually in the payload
        const relationsToProcess = relations.filter((relation) => {
            if (!relation.one_field)
                return false;
            return relation.one_field in payload;
        });
        const nestedUpdateSchema = joi_1.default.object({
            create: joi_1.default.array().items(joi_1.default.object().unknown()),
            update: joi_1.default.array().items(joi_1.default.object().unknown()),
            delete: joi_1.default.array().items(joi_1.default.string(), joi_1.default.number()),
        });
        for (const relation of relationsToProcess) {
            if (!payload[relation.one_field])
                continue;
            const itemsService = new items_1.ItemsService(relation.many_collection, {
                accountability: this.accountability,
                knex: this.knex,
                schema: this.schema,
            });
            const relatedRecords = [];
            // Nested array of individual items
            if (Array.isArray(payload[relation.one_field])) {
                for (let i = 0; i < (payload[relation.one_field] || []).length; i++) {
                    const relatedRecord = (payload[relation.one_field] || [])[i];
                    let record = lodash_1.cloneDeep(relatedRecord);
                    if (typeof relatedRecord === 'string' || typeof relatedRecord === 'number') {
                        const exists = !!(await this.knex
                            .select(relation.many_primary)
                            .from(relation.many_collection)
                            .where({ [relation.many_primary]: record })
                            .first());
                        if (exists === false) {
                            throw new exceptions_1.ForbiddenException();
                        }
                        record = {
                            [relation.many_primary]: relatedRecord,
                        };
                    }
                    relatedRecords.push({
                        ...record,
                        [relation.many_field]: parent || payload[relation.one_primary],
                    });
                }
                const savedPrimaryKeys = await itemsService.upsertMany(relatedRecords);
                // Nullify all related items that aren't included in the current payload
                await itemsService.updateByQuery({
                    filter: {
                        _and: [
                            {
                                [relation.many_field]: {
                                    _eq: parent,
                                },
                            },
                            {
                                [relation.many_primary]: {
                                    _nin: savedPrimaryKeys,
                                },
                            },
                        ],
                    },
                }, { [relation.many_field]: null });
            }
            // "Updates" object w/ create/update/delete
            else {
                const alterations = payload[relation.one_field];
                const { error } = nestedUpdateSchema.validate(alterations);
                if (error)
                    throw new exceptions_1.InvalidPayloadException(`Invalid one-to-many update structure: ${error.message}`);
                if (alterations.create) {
                    await itemsService.createMany(alterations.create.map((item) => ({
                        ...item,
                        [relation.many_field]: parent || payload[relation.one_primary],
                    })));
                }
                if (alterations.update) {
                    const primaryKeyField = this.schema.collections[this.collection].primary;
                    for (const item of alterations.update) {
                        await itemsService.updateOne(item[primaryKeyField], {
                            ...item,
                            [relation.many_field]: parent || payload[relation.one_primary],
                        });
                    }
                }
                if (alterations.delete) {
                    await itemsService.updateByQuery({
                        filter: {
                            _and: [
                                {
                                    [relation.many_field]: {
                                        _eq: parent,
                                    },
                                },
                                {
                                    [relation.many_primary]: {
                                        _in: alterations.delete,
                                    },
                                },
                            ],
                        },
                    }, { [relation.many_field]: null });
                }
            }
        }
        return { revisions };
    }
}
exports.PayloadService = PayloadService;
