import { Knex } from 'knex';
import { AbstractServiceOptions, Accountability, Item, PrimaryKey, SchemaOverview } from '../types';
declare type Action = 'create' | 'read' | 'update';
declare type Transformers = {
    [type: string]: (context: {
        action: Action;
        value: any;
        payload: Partial<Item>;
        accountability: Accountability | null;
    }) => Promise<any>;
};
/**
 * Process a given payload for a collection to ensure the special fields (hash, uuid, date etc) are
 * handled correctly.
 */
export declare class PayloadService {
    accountability: Accountability | null;
    knex: Knex;
    collection: string;
    schema: SchemaOverview;
    constructor(collection: string, options: AbstractServiceOptions);
    /**
     * @todo allow this to be extended
     *
     * @todo allow these extended special types to have "field dependencies"?
     * f.e. the file-links transformer needs the id and filename_download to be fetched from the DB
     * in order to work
     */
    transformers: Transformers;
    processValues(action: Action, payloads: Partial<Item>[]): Promise<Partial<Item>[]>;
    processValues(action: Action, payload: Partial<Item>): Promise<Partial<Item>>;
    processField(field: SchemaOverview['collections'][string]['fields'][string], payload: Partial<Item>, action: Action, accountability: Accountability | null): Promise<any>;
    /**
     * Knex returns `datetime` and `date` columns as Date.. This is wrong for date / datetime, as those
     * shouldn't return with time / timezone info respectively
     */
    processDates(payloads: Partial<Record<string, any>>[], action: Action): Promise<Partial<Record<string, any>>[]>;
    /**
     * Recursively save/update all nested related Any-to-One items
     */
    processA2O(data: Partial<Item>): Promise<{
        payload: Partial<Item>;
        revisions: PrimaryKey[];
    }>;
    /**
     * Save/update all nested related m2o items inside the payload
     */
    processM2O(data: Partial<Item>): Promise<{
        payload: Partial<Item>;
        revisions: PrimaryKey[];
    }>;
    /**
     * Recursively save/update all nested related o2m items
     */
    processO2M(data: Partial<Item>, parent: PrimaryKey): Promise<{
        revisions: PrimaryKey[];
    }>;
}
export {};
