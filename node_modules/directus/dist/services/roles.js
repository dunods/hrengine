"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RolesService = void 0;
const exceptions_1 = require("../exceptions");
const items_1 = require("./items");
const permissions_1 = require("./permissions");
const presets_1 = require("./presets");
const users_1 = require("./users");
class RolesService extends items_1.ItemsService {
    constructor(options) {
        super('directus_roles', options);
    }
    async deleteOne(key) {
        await this.deleteMany([key]);
        return key;
    }
    async deleteMany(keys) {
        // Make sure there's at least one admin role left after this deletion is done
        const otherAdminRoles = await this.knex
            .count('*', { as: 'count' })
            .from('directus_roles')
            .whereNotIn('id', keys)
            .andWhere({ admin_access: true })
            .first();
        const otherAdminRolesCount = +((otherAdminRoles === null || otherAdminRoles === void 0 ? void 0 : otherAdminRoles.count) || 0);
        if (otherAdminRolesCount === 0)
            throw new exceptions_1.UnprocessableEntityException(`You can't delete the last admin role.`);
        await this.knex.transaction(async (trx) => {
            const itemsService = new items_1.ItemsService('directus_roles', {
                knex: trx,
                accountability: this.accountability,
                schema: this.schema,
            });
            const permissionsService = new permissions_1.PermissionsService({
                knex: trx,
                accountability: this.accountability,
                schema: this.schema,
            });
            const presetsService = new presets_1.PresetsService({
                knex: trx,
                accountability: this.accountability,
                schema: this.schema,
            });
            const usersService = new users_1.UsersService({
                knex: trx,
                accountability: this.accountability,
                schema: this.schema,
            });
            // Delete permissions/presets for this role, suspend all remaining users in role
            await permissionsService.deleteByQuery({
                filter: { role: { _in: keys } },
            });
            await presetsService.deleteByQuery({
                filter: { role: { _in: keys } },
            });
            await usersService.updateByQuery({
                filter: { role: { _in: keys } },
            }, {
                status: 'suspended',
                role: null,
            });
            await itemsService.deleteMany(keys);
        });
        return keys;
    }
    async delete(key) {
        if (Array.isArray(key))
            return await this.deleteMany(key);
        return await this.deleteOne(key);
    }
}
exports.RolesService = RolesService;
