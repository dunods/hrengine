"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RelationsService = void 0;
const relations_1 = require("../database/system-data/relations");
const exceptions_1 = require("../exceptions");
const logger_1 = __importDefault(require("../logger"));
const to_array_1 = require("../utils/to-array");
const items_1 = require("./items");
const permissions_1 = require("./permissions");
class RelationsService extends items_1.ItemsService {
    constructor(options) {
        super('directus_relations', options);
        this.permissionsService = new permissions_1.PermissionsService(options);
    }
    /**
     * Read multiple relations by query.
     *
     * Note: this is based on permissions access to other collections/fields, not permissions to
     * directus_relations directly
     */
    async readByQuery(query, opts) {
        const service = new items_1.ItemsService('directus_relations', {
            knex: this.knex,
            schema: this.schema,
            // We don't set accountability here. If you have read access to certain fields, you are
            // allowed to extract the relations regardless of permissions to directus_relations. This
            // happens in `filterForbidden` down below
        });
        const results = await service.readByQuery(query, opts);
        results.push(...relations_1.systemRelationRows);
        const filteredResults = await this.filterForbidden(results);
        return filteredResults;
    }
    /**
     * Get a single relations row by key. This is based on your permissions to the collections/fields
     * involved in the relation, not permissions to directus_relations
     */
    async readOne(key, query, opts) {
        const service = new items_1.ItemsService('directus_relations', {
            knex: this.knex,
            schema: this.schema,
            // We don't set accountability here. If you have read access to certain fields, you are
            // allowed to extract the relations regardless of permissions to directus_relations. This
            // happens in `filterForbidden` down below
        });
        const result = await service.readOne(key, query, opts);
        // No need to merge system relations here. They don't have PKs so can never be directly
        // targeted
        const filteredResults = await this.filterForbidden([result]);
        if (filteredResults.length === 1)
            return filteredResults[0];
        throw new exceptions_1.ForbiddenException();
    }
    /**
     * Get a single relations row by key. This is based on your permissions to the collections/fields
     * involved in the relation, not permissions to directus_relations
     */
    async readMany(keys, query, opts) {
        const service = new items_1.ItemsService('directus_relations', {
            knex: this.knex,
            schema: this.schema,
            // We don't set accountability here. If you have read access to certain fields, you are
            // allowed to extract the relations regardless of permissions to directus_relations. This
            // happens in `filterForbidden` down below
        });
        const result = await service.readMany(keys, query, opts);
        // No need to merge system relations here. They don't have PKs so can never be directly
        // targeted
        const filteredResults = await this.filterForbidden(result);
        if (filteredResults.length === 0)
            throw new exceptions_1.ForbiddenException();
        return filteredResults;
    }
    /**
     * Loop over all relations and filter out the ones that contain collections/fields you don't have
     * permissions to
     */
    async filterForbidden(relations) {
        var _a;
        if (this.accountability === null || ((_a = this.accountability) === null || _a === void 0 ? void 0 : _a.admin) === true)
            return relations;
        const allowedCollections = this.schema.permissions
            .filter((permission) => {
            return permission.action === 'read';
        })
            .map(({ collection }) => collection);
        const allowedFields = this.permissionsService.getAllowedFields('read');
        relations = to_array_1.toArray(relations);
        return relations.filter((relation) => {
            let collectionsAllowed = true;
            let fieldsAllowed = true;
            if (allowedCollections.includes(relation.many_collection) === false) {
                collectionsAllowed = false;
            }
            if (relation.one_collection && allowedCollections.includes(relation.one_collection) === false) {
                collectionsAllowed = false;
            }
            if (relation.one_allowed_collections &&
                relation.one_allowed_collections.every((collection) => allowedCollections.includes(collection)) === false) {
                collectionsAllowed = false;
            }
            if (!allowedFields[relation.many_collection] ||
                (allowedFields[relation.many_collection].includes('*') === false &&
                    allowedFields[relation.many_collection].includes(relation.many_field) === false)) {
                fieldsAllowed = false;
            }
            if (relation.one_collection &&
                relation.one_field &&
                (!allowedFields[relation.one_collection] ||
                    (allowedFields[relation.one_collection].includes('*') === false &&
                        allowedFields[relation.one_collection].includes(relation.one_field) === false))) {
                fieldsAllowed = false;
            }
            return collectionsAllowed && fieldsAllowed;
        });
    }
    async readByKey(key, query = {}, action = 'read') {
        logger_1.default.warn('RelationsService.readByKey is deprecated and will be removed before v9.0.0. Use readOne or readMany instead.');
        if (Array.isArray(key))
            return await this.readMany(key, query, { permissionsAction: action });
        return await this.readOne(key, query, { permissionsAction: action });
    }
}
exports.RelationsService = RelationsService;
