"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FilesService = void 0;
const format_title_1 = __importDefault(require("@directus/format-title"));
const axios_1 = __importDefault(require("axios"));
const exif_reader_1 = __importDefault(require("exif-reader"));
const icc_1 = require("icc");
const lodash_1 = require("lodash");
const mime_types_1 = require("mime-types");
const path_1 = __importDefault(require("path"));
const sharp_1 = __importDefault(require("sharp"));
const url_1 = __importDefault(require("url"));
const cache_1 = __importDefault(require("../cache"));
const emitter_1 = require("../emitter");
const env_1 = __importDefault(require("../env"));
const exceptions_1 = require("../exceptions");
const logger_1 = __importDefault(require("../logger"));
const storage_1 = __importDefault(require("../storage"));
const parse_iptc_1 = __importDefault(require("../utils/parse-iptc"));
const to_array_1 = require("../utils/to-array");
const items_1 = require("./items");
class FilesService extends items_1.ItemsService {
    constructor(options) {
        super('directus_files', options);
    }
    /**
     * Upload a single new file to the configured storage adapter
     */
    async uploadOne(stream, data, primaryKey) {
        const payload = lodash_1.clone(data);
        if (primaryKey !== undefined) {
            await this.updateOne(primaryKey, payload, { emitEvents: false });
            // If the file you're uploading already exists, we'll consider this upload a replace. In that case, we'll
            // delete the previously saved file and thumbnails to ensure they're generated fresh
            const disk = storage_1.default.disk(payload.storage);
            for await (const file of disk.flatList(String(primaryKey))) {
                await disk.delete(file.path);
            }
        }
        else {
            primaryKey = await this.createOne(payload, { emitEvents: false });
        }
        const fileExtension = (payload.type && mime_types_1.extension(payload.type)) || path_1.default.extname(payload.filename_download);
        payload.filename_disk = primaryKey + '.' + fileExtension;
        if (!payload.type) {
            payload.type = 'application/octet-stream';
        }
        try {
            await storage_1.default.disk(data.storage).put(payload.filename_disk, stream, payload.type);
        }
        catch (err) {
            logger_1.default.warn(`Couldn't save file ${payload.filename_disk}`);
            logger_1.default.warn(err);
        }
        const { size } = await storage_1.default.disk(data.storage).getStat(payload.filename_disk);
        payload.filesize = size;
        if (['image/jpeg', 'image/png', 'image/webp', 'image/gif', 'image/tiff'].includes(payload.type)) {
            const buffer = await storage_1.default.disk(data.storage).getBuffer(payload.filename_disk);
            const meta = await sharp_1.default(buffer.content, {}).metadata();
            if (meta.orientation && meta.orientation >= 5) {
                payload.height = meta.width;
                payload.width = meta.height;
            }
            else {
                payload.width = meta.width;
                payload.height = meta.height;
            }
            payload.filesize = meta.size;
            payload.metadata = {};
            if (meta.icc) {
                try {
                    payload.metadata.icc = icc_1.parse(meta.icc);
                }
                catch (err) {
                    logger_1.default.warn(`Couldn't extract ICC information from file`);
                    logger_1.default.warn(err);
                }
            }
            if (meta.exif) {
                try {
                    payload.metadata.exif = exif_reader_1.default(meta.exif);
                }
                catch (err) {
                    logger_1.default.warn(`Couldn't extract EXIF information from file`);
                    logger_1.default.warn(err);
                }
            }
            if (meta.iptc) {
                try {
                    payload.metadata.iptc = parse_iptc_1.default(meta.iptc);
                    payload.title = payload.title || payload.metadata.iptc.headline;
                    payload.description = payload.description || payload.metadata.iptc.caption;
                }
                catch (err) {
                    logger_1.default.warn(`Couldn't extract IPTC information from file`);
                    logger_1.default.warn(err);
                }
            }
        }
        // We do this in a service without accountability. Even if you don't have update permissions to the file,
        // we still want to be able to set the extracted values from the file on create
        const sudoService = new items_1.ItemsService('directus_files', {
            knex: this.knex,
            schema: this.schema,
        });
        await sudoService.updateOne(primaryKey, payload, { emitEvents: false });
        if (cache_1.default && env_1.default.CACHE_AUTO_PURGE) {
            await cache_1.default.clear();
        }
        emitter_1.emitAsyncSafe(`files.upload`, {
            event: `files.upload`,
            accountability: this.accountability,
            collection: this.collection,
            item: primaryKey,
            action: 'upload',
            payload,
            schema: this.schema,
            database: this.knex,
        });
        return primaryKey;
    }
    /**
     * Import a single file from an external URL
     */
    async importOne(importURL, body) {
        var _a;
        const fileCreatePermissions = this.schema.permissions.find((permission) => permission.collection === 'directus_files' && permission.action === 'create');
        if (((_a = this.accountability) === null || _a === void 0 ? void 0 : _a.admin) !== true && !fileCreatePermissions) {
            throw new exceptions_1.ForbiddenException();
        }
        let fileResponse;
        try {
            fileResponse = await axios_1.default.get(importURL, {
                responseType: 'stream',
            });
        }
        catch (err) {
            logger_1.default.warn(`Couldn't fetch file from url "${importURL}"`);
            logger_1.default.warn(err);
            throw new exceptions_1.ServiceUnavailableException(`Couldn't fetch file from url "${importURL}"`, {
                service: 'external-file',
            });
        }
        const parsedURL = url_1.default.parse(fileResponse.request.res.responseUrl);
        const filename = path_1.default.basename(parsedURL.pathname);
        const payload = {
            filename_download: filename,
            storage: to_array_1.toArray(env_1.default.STORAGE_LOCATIONS)[0],
            type: fileResponse.headers['content-type'],
            title: format_title_1.default(filename),
            ...(body || {}),
        };
        return await this.uploadOne(fileResponse.data, payload);
    }
    /**
     * Delete a file
     */
    async deleteOne(key, opts) {
        await this.deleteMany([key], opts);
        return key;
    }
    /**
     * Delete multiple files
     */
    async deleteMany(keys, opts) {
        const files = await super.readMany(keys, { fields: ['id', 'storage'] });
        if (!files) {
            throw new exceptions_1.ForbiddenException();
        }
        await super.deleteMany(keys);
        for (const file of files) {
            const disk = storage_1.default.disk(file.storage);
            // Delete file + thumbnails
            for await (const { path } of disk.flatList(file.id)) {
                await disk.delete(path);
            }
        }
        if (cache_1.default && env_1.default.CACHE_AUTO_PURGE && (opts === null || opts === void 0 ? void 0 : opts.autoPurgeCache) !== false) {
            await cache_1.default.clear();
        }
        return keys;
    }
    /**
     * @deprecated Use `uploadOne` instead
     */
    async upload(stream, data, primaryKey) {
        logger_1.default.warn('FilesService.upload is deprecated and will be removed before v9.0.0. Use uploadOne instead.');
        return await this.uploadOne(stream, data, primaryKey);
    }
    /**
     * @deprecated Use `importOne` instead
     */
    async import(importURL, body) {
        return await this.importOne(importURL, body);
    }
    async delete(key) {
        logger_1.default.warn('FilesService.delete is deprecated and will be removed before v9.0.0. Use deleteOne or deleteMany instead.');
        if (Array.isArray(key))
            return await this.deleteMany(key);
        return await this.deleteOne(key);
    }
}
exports.FilesService = FilesService;
