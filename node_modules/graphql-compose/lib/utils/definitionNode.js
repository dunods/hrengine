"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getUnionTypeDefinitionNode = exports.getScalarTypeDefinitionNode = exports.getInterfaceTypeDefinitionNode = exports.getEnumTypeDefinitionNode = exports.getInputObjectTypeDefinitionNode = exports.getObjectTypeDefinitionNode = void 0;
const graphql_1 = require("../graphql");
const ThunkComposer_1 = require("../ThunkComposer");
const NonNullComposer_1 = require("../NonNullComposer");
const ListComposer_1 = require("../ListComposer");
function getObjectTypeDefinitionNode(tc) {
    return {
        kind: 'ObjectTypeDefinition',
        name: { kind: 'Name', value: tc.getTypeName() },
        description: getDescriptionNode(tc.getDescription()),
        directives: getDirectiveNodes(tc.getDirectives(), tc.schemaComposer),
        interfaces: getInterfaceNodes(tc.getInterfaces()),
        fields: getFieldDefinitionNodes(tc),
    };
}
exports.getObjectTypeDefinitionNode = getObjectTypeDefinitionNode;
function getInputObjectTypeDefinitionNode(tc) {
    return {
        kind: 'InputObjectTypeDefinition',
        name: { kind: 'Name', value: tc.getTypeName() },
        directives: getDirectiveNodes(tc.getDirectives(), tc.schemaComposer),
        description: getDescriptionNode(tc.getDescription()),
        fields: getInputValueDefinitionNodes(tc),
    };
}
exports.getInputObjectTypeDefinitionNode = getInputObjectTypeDefinitionNode;
function getEnumTypeDefinitionNode(tc) {
    return {
        kind: 'EnumTypeDefinition',
        name: { kind: 'Name', value: tc.getTypeName() },
        description: getDescriptionNode(tc.getDescription()),
        directives: getDirectiveNodes(tc.getDirectives(), tc.schemaComposer),
        values: getEnumValueDefinitionNodes(tc),
    };
}
exports.getEnumTypeDefinitionNode = getEnumTypeDefinitionNode;
function getInterfaceTypeDefinitionNode(tc) {
    return {
        kind: 'InterfaceTypeDefinition',
        name: { kind: 'Name', value: tc.getTypeName() },
        description: getDescriptionNode(tc.getDescription()),
        directives: getDirectiveNodes(tc.getDirectives(), tc.schemaComposer),
        fields: getFieldDefinitionNodes(tc),
    };
}
exports.getInterfaceTypeDefinitionNode = getInterfaceTypeDefinitionNode;
function getScalarTypeDefinitionNode(tc) {
    return {
        kind: 'ScalarTypeDefinition',
        name: { kind: 'Name', value: tc.getTypeName() },
        description: getDescriptionNode(tc.getDescription()),
        directives: getDirectiveNodes(tc.getDirectives(), tc.schemaComposer),
    };
}
exports.getScalarTypeDefinitionNode = getScalarTypeDefinitionNode;
function getUnionTypeDefinitionNode(tc) {
    return {
        kind: 'UnionTypeDefinition',
        name: { kind: 'Name', value: tc.getTypeName() },
        description: getDescriptionNode(tc.getDescription()),
        directives: getDirectiveNodes(tc.getDirectives(), tc.schemaComposer),
        types: tc.getTypeNames().map((value) => ({
            kind: 'NamedType',
            name: { kind: 'Name', value },
        })),
    };
}
exports.getUnionTypeDefinitionNode = getUnionTypeDefinitionNode;
function getDescriptionNode(_value) {
    return;
}
function toValueNode(value) {
    switch (typeof value) {
        case 'string':
            return { kind: 'StringValue', value };
        case 'number':
            if (Number.isInteger(value))
                return { kind: 'IntValue', value: value.toString() };
            return { kind: 'FloatValue', value: value.toString() };
        case 'boolean':
            return { kind: 'BooleanValue', value };
        case 'object':
            if (value === null) {
                return { kind: 'NullValue' };
            }
            else if (Array.isArray(value)) {
                return {
                    kind: 'ListValue',
                    values: value.map((v) => toValueNode(v)),
                };
            }
            else {
                return {
                    kind: 'ObjectValue',
                    fields: Object.keys(value).map((k) => ({
                        kind: 'ObjectField',
                        name: { kind: 'Name', value: k },
                        value: toValueNode(value[k]),
                    })),
                };
            }
        default:
            return { kind: 'NullValue' };
    }
}
function getDirectiveArgumentNodes(data, directive) {
    const keys = Object.keys(data);
    if (!keys.length)
        return;
    const args = [];
    keys.forEach((k) => {
        var _a;
        let argumentType;
        if (directive) {
            argumentType = (_a = directive.args.find((d) => d.name === k)) === null || _a === void 0 ? void 0 : _a.type;
        }
        const argNode = {
            kind: 'Argument',
            name: { kind: 'Name', value: k },
            value: argumentType
                ?
                    graphql_1.astFromValue(data[k], argumentType) || { kind: 'NullValue' }
                :
                    toValueNode(data[k]),
        };
        args.push(argNode);
    });
    return args;
}
function getDirectiveNodes(values, sc) {
    if (!values || !values.length)
        return;
    return values.map((v) => ({
        kind: 'Directive',
        name: { kind: 'Name', value: v.name },
        arguments: getDirectiveArgumentNodes(v.args, sc._getDirective(v.name)),
    }));
}
function getInterfaceNodes(ifaces) {
    return ifaces
        .map((iface) => {
        if (!iface || !iface.getTypeName)
            return;
        return {
            kind: 'NamedType',
            name: { kind: 'Name', value: iface.getTypeName() },
        };
    })
        .filter(Boolean);
}
function getTypeNode(atc) {
    if (atc instanceof ThunkComposer_1.ThunkComposer) {
        return getTypeNode(atc.ofType);
    }
    else if (atc instanceof ListComposer_1.ListComposer) {
        const subType = getTypeNode(atc.ofType);
        if (!subType)
            return;
        return {
            kind: 'ListType',
            type: subType,
        };
    }
    else if (atc instanceof NonNullComposer_1.NonNullComposer) {
        const subType = getTypeNode(atc.ofType);
        if (!subType)
            return;
        return {
            kind: 'NonNullType',
            type: subType,
        };
    }
    else if (atc && atc.getTypeName) {
        return {
            kind: 'NamedType',
            name: { kind: 'Name', value: atc.getTypeName() },
        };
    }
    return undefined;
}
function getArgumentsDefinitionNodes(tc, fieldName) {
    const argNames = tc.getFieldArgNames(fieldName);
    if (!argNames.length)
        return;
    return argNames
        .map((argName) => {
        const ac = tc.getFieldArg(fieldName, argName);
        const type = getTypeNode(ac.type);
        if (!type)
            return;
        return {
            kind: 'InputValueDefinition',
            name: { kind: 'Name', value: argName },
            type,
            description: getDescriptionNode(ac.description),
            directives: getDirectiveNodes(tc.getFieldArgDirectives(fieldName, argName), tc.schemaComposer),
            defaultValue: (ac.defaultValue !== undefined &&
                graphql_1.astFromValue(ac.defaultValue, tc.getFieldArgType(fieldName, argName))) ||
                undefined,
        };
    })
        .filter(Boolean);
}
function getFieldDefinitionNodes(tc) {
    const fieldNames = tc.getFieldNames();
    if (!fieldNames.length)
        return;
    return fieldNames
        .map((fieldName) => {
        const fc = tc.getField(fieldName);
        const type = getTypeNode(fc.type);
        if (!type)
            return;
        return {
            kind: 'FieldDefinition',
            name: { kind: 'Name', value: fieldName },
            type,
            arguments: getArgumentsDefinitionNodes(tc, fieldName),
            description: getDescriptionNode(fc.description),
            directives: getDirectiveNodes(tc.getFieldDirectives(fieldName), tc.schemaComposer),
        };
    })
        .filter(Boolean);
}
function getInputValueDefinitionNodes(tc) {
    const fieldNames = tc.getFieldNames();
    if (!fieldNames.length)
        return;
    return fieldNames
        .map((fieldName) => {
        const fc = tc.getField(fieldName);
        const type = getTypeNode(fc.type);
        if (!type)
            return;
        return {
            kind: 'InputValueDefinition',
            name: { kind: 'Name', value: fieldName },
            type,
            description: getDescriptionNode(fc.description),
            directives: getDirectiveNodes(tc.getFieldDirectives(fieldName), tc.schemaComposer),
            defaultValue: (fc.defaultValue !== undefined &&
                graphql_1.astFromValue(fc.defaultValue, tc.getFieldType(fieldName))) ||
                undefined,
        };
    })
        .filter(Boolean);
}
function getEnumValueDefinitionNodes(tc) {
    const fieldNames = tc.getFieldNames();
    if (!fieldNames.length)
        return;
    return fieldNames.map((fieldName) => {
        const fc = tc.getField(fieldName);
        return {
            kind: 'EnumValueDefinition',
            name: { kind: 'Name', value: fieldName },
            description: getDescriptionNode(fc.description),
            directives: getDirectiveNodes(tc.getFieldDirectives(fieldName), tc.schemaComposer),
        };
    });
}
//# sourceMappingURL=definitionNode.js.map